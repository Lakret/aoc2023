<!-- livebook:{"persist_outputs":true} -->

# Day 12

## Solution

```elixir
Enum.split_with([1, 2, 3], fn x -> x > 2 end)
```

<!-- livebook:{"output":true} -->

```
{[3], [1, 2]}
```

```elixir
String.at(".##?..", 3)
```

<!-- livebook:{"output":true} -->

```
"?"
```

```elixir
defmodule D12 do
  @char_to_is_damaged %{"?" => nil, "." => false, "#" => true}
  @is_damaged_to_char %{nil => "?", false => ".", true => "#"}

  def parse_input(input) do
    input
    |> String.split("\n", trim: true)
    |> Enum.map(fn line ->
      [states, damaged] = String.split(line)

      states =
        String.graphemes(states)
        |> Enum.map(&@char_to_is_damaged[&1])
        |> Enum.chunk_by(& &1)
        |> Enum.map(fn [state | _] = group -> {length(group), state} end)

      damaged =
        damaged
        |> String.split(",")
        |> Enum.map(&String.to_integer/1)

      {states, damaged}
    end)
  end

  # TODO: better model for checking consistency and speed:
  # instead of map from pos to value, let's do a run-length encoding list, perhaps?
  # ?###????????. 3,2,1
  # [{1, nil}, {3, true}, {8, nil}, {1, false}]
  # 
  # then, we can introduce stronger constraints (e.g., we know that fitting more than one
  # of the damaged groups inside an unknown group requires additional spaces for each 
  # damaged group; we also can see in the example above that the first ? is always false)
  def solve(states, damaged) when is_list(states) and is_list(damaged) do
    {unknown, known} =
      Enum.with_index(states, fn el, id -> {id, el} end)
      |> Enum.split_with(fn {_group_id, {_run_length, state}} -> is_nil(state) end)

    if length(unknown) > 0 do
      solve_inner(
        Enum.into(unknown, %{}),
        Enum.into(known, %{}),
        damaged,
        length(states)
      )
    else
      [states]
    end
  end

  @doc false
  def solve_inner(unknown, known, damaged, n)

  def solve_inner(unknown, known, _damaged, _n)
      when map_size(unknown) == 0,
      do: [known]

  def solve_inner(unknown, known, damaged, n) do
    IO.inspect({unknown, known, damaged, n})
    unknown_id = Map.keys(unknown) |> Enum.min()
    unknown = Map.delete(unknown, unknown_id)

    # TODO: different domain! we need to add groups for each assignment of variables possible
    # depending on the run-length of the group, it seems
    Enum.flat_map([true, false], fn possible_value ->
      known = Map.put(known, unknown_id, possible_value)

      if consistent?(known, damaged, n) do
        # TODO: known_states = infer(known_states)
        solve_inner(unknown, known, damaged, n)
      else
        []
      end
    end)
  end

  def consistent?(known, damaged, n) do
    # TODO:
    # Enum.reduce_while(0..n, damaged, fn id, damaged -> 
    #   known_states
    # end)
  end
end
```

<!-- livebook:{"output":true} -->

```
warning: variable "damaged" is unused (if the variable is not meant to be used, prefix it with an underscore)
  d12.livemd#cell:i5msuh4vivy2x4cfxxjodzweyrzkfdn6:76: D12.consistent?/3

warning: variable "known" is unused (if the variable is not meant to be used, prefix it with an underscore)
  d12.livemd#cell:i5msuh4vivy2x4cfxxjodzweyrzkfdn6:76: D12.consistent?/3

warning: variable "n" is unused (if the variable is not meant to be used, prefix it with an underscore)
  d12.livemd#cell:i5msuh4vivy2x4cfxxjodzweyrzkfdn6:76: D12.consistent?/3

warning: module attribute @is_damaged_to_char was set but never used
  d12.livemd#cell:i5msuh4vivy2x4cfxxjodzweyrzkfdn6:3

```

<!-- livebook:{"output":true} -->

```
{:module, D12, <<70, 79, 82, 49, 0, 0, 19, ...>>, {:consistent?, 3}}
```

```elixir
test_input = """
???.### 1,1,3
.??..??...?##. 1,1,3
?#?#?#?#?#?#?#? 1,3,1,6
????.#...#... 4,1,1
????.######..#####. 1,6,5
?###???????? 3,2,1
"""
```

<!-- livebook:{"output":true} -->

```
"???.### 1,1,3\n.??..??...?##. 1,1,3\n?#?#?#?#?#?#?#? 1,3,1,6\n????.#...#... 4,1,1\n????.######..#####. 1,6,5\n?###???????? 3,2,1\n"
```

```elixir
test_input = D12.parse_input(test_input)
```

<!-- livebook:{"output":true} -->

```
[
  {[{3, nil}, {1, false}, {3, true}], [1, 1, 3]},
  {[{1, false}, {2, nil}, {2, false}, {2, nil}, {3, false}, {1, nil}, {2, true}, {1, false}],
   [1, 1, 3]},
  {[
     {1, nil},
     {1, true},
     {1, nil},
     {1, true},
     {1, nil},
     {1, true},
     {1, nil},
     {1, true},
     {1, nil},
     {1, true},
     {1, nil},
     {1, true},
     {1, nil},
     {1, true},
     {1, nil}
   ], [1, 3, 1, 6]},
  {[{4, nil}, {1, false}, {1, true}, {3, false}, {1, true}, {3, false}], [4, 1, 1]},
  {[{4, nil}, {1, false}, {6, true}, {2, false}, {5, true}, {1, false}], [1, 6, 5]},
  {[{1, nil}, {3, true}, {8, nil}], [3, 2, 1]}
]
```

```elixir
{states, damaged} = test_input |> hd
```

<!-- livebook:{"output":true} -->

```
{[{3, nil}, {1, false}, {3, true}], [1, 1, 3]}
```

```elixir
D12.solve(states, damaged)
```

<!-- livebook:{"output":true} -->

```
{%{0 => {3, nil}}, %{1 => {1, false}, 2 => {3, true}}, [1, 1, 3], 3}
```

<!-- livebook:{"output":true} -->

```
[]
```

```elixir
# TODO: how to distribute [1, 1] into 0 group above?
# we can compute that 1 + 1 will require 3, so we can take all damaged up to the current point
# up to the threshold defined as the damaged lengths + required spaces 
```

<!-- livebook:{"output":true} -->

```
nil
```

## Tests

```elixir
ExUnit.start(autorun: false)

defmodule D08Test do
  use ExUnit.Case, async: true

  # @test_input1 D08.parse_input("""
  #              RL

  #              AAA = (BBB, CCC)
  #              BBB = (DDD, EEE)
  #              CCC = (ZZZ, GGG)
  #              DDD = (DDD, DDD)
  #              EEE = (EEE, EEE)
  #              GGG = (GGG, GGG)
  #              ZZZ = (ZZZ, ZZZ)
  #              """)

  # @test_input2 D08.parse_input("""
  #              LLR

  #              AAA = (BBB, BBB)
  #              BBB = (AAA, ZZZ)
  #              ZZZ = (ZZZ, ZZZ)
  #              """)

  # @test_input3 D08.parse_input("""
  #              LR

  #              11A = (11B, XXX)
  #              11B = (XXX, 11Z)
  #              11Z = (11B, XXX)
  #              22A = (22B, XXX)
  #              22B = (22C, 22C)
  #              22C = (22Z, 22Z)
  #              22Z = (22B, 22B)
  #              XXX = (XXX, XXX)
  #              """)

  # @input Path.join(__DIR__, "inputs/d08") |> File.read!() |> D08.parse_input()

  # test "part 1 works" do
  #   {moves, network} = @test_input1
  #   assert D08.p1(moves, network) == 2

  #   {moves, network} = @test_input2
  #   assert D08.p1(moves, network) == 6

  #   {moves, network} = @input
  #   assert D08.p1(moves, network) == 19783
  # end

  # test "part 2 works" do
  #   {moves, network} = @test_input3
  #   assert D08.p2(moves, network) == 6

  #   {moves, network} = @input
  #   assert D08.p2(moves, network) == 9_177_460_370_549
  # end
end

ExUnit.run()
```

<!-- livebook:{"output":true} -->

```

Finished in 0.00 seconds (0.00s async, 0.00s sync)
0 failures

Randomized with seed 71107
```

<!-- livebook:{"output":true} -->

```
%{excluded: 0, failures: 0, skipped: 0, total: 0}
```
