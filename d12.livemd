<!-- livebook:{"persist_outputs":true} -->

# Day 12

## Solution

```elixir
Enum.split_with([1, 2, 3], fn x -> x > 2 end)
```

<!-- livebook:{"output":true} -->

```
{[3], [1, 2]}
```

```elixir
String.at(".##?..", 3)
```

<!-- livebook:{"output":true} -->

```
"?"
```

```elixir
defmodule D12 do
  @char_to_is_damaged %{"?" => nil, "." => false, "#" => true}
  @is_damaged_to_char %{nil => "?", false => ".", true => "#"}

  def parse_input(input) do
    input
    |> String.split("\n", trim: true)
    |> Enum.map(fn line ->
      [states, damaged] = String.split(line)
      states = String.graphemes(states) |> Enum.map(&@char_to_is_damaged[&1])
      damaged = damaged |> String.split(",") |> Enum.map(&String.to_integer/1)
      {states, damaged}
    end)
  end

  # TODO: better model for checking consistency and speed:
  # instead of map from pos to value, let's do a run-length encoding list, perhaps?
  # ?###????????. 3,2,1
  # [{1, nil}, {3, true}, {8, nil}, {1, false}]
  # 
  # then, we can introduce stronger constraints (e.g., we know that fitting more than one
  # of the damaged groups inside an unknown group requires additional spaces for each 
  # damaged group; we also can see in the example above that the first ? is always false)
  def solve(states, damaged) when is_list(states) and is_list(damaged) do
    if Enum.any?(states, &is_nil/1) do
      {unknown_states, known_states} =
        Enum.with_index(states, fn el, id -> {id, el} end)
        |> Enum.split_with(fn {_id, el} -> is_nil(el) end)

      solve_inner(
        Enum.into(unknown_states, %{}),
        Enum.into(known_states, %{}),
        damaged,
        length(states)
      )
    else
      [states]
    end
  end

  @doc false
  def solve_inner(unknown_states, known_states, damaged, n)

  def solve_inner(unknown_states, known_states, _damaged, _n)
      when map_size(unknown_states) == 0,
      do: [known_states]

  def solve_inner(unknown_states, known_states, damaged, n) do
    IO.inspect({unknown_states, known_states, damaged})
    unknown_id = Map.keys(unknown_states) |> Enum.min()
    unknown_states = Map.delete(unknown_states, unknown_id)

    Enum.flat_map([true, false], fn possible_value ->
      known_states = Map.put(known_states, unknown_id, possible_value)

      if consistent?(known_states, damaged, n) do
        # TODO: known_states = infer(known_states)
        solve_inner(unknown_states, known_states, damaged, n)
      else
        []
      end
    end)
  end

  def consistent?(known_states, damaged, n) do
    # TODO:
    # Enum.reduce_while(0..n, damaged, fn id, damaged -> 
    #   known_states
    # end)
  end
end
```

<!-- livebook:{"output":true} -->

```
warning: variable "damaged" is unused (if the variable is not meant to be used, prefix it with an underscore)
  d12.livemd#cell:i5msuh4vivy2x4cfxxjodzweyrzkfdn6:64: D12.consistent?/3

warning: variable "known_states" is unused (if the variable is not meant to be used, prefix it with an underscore)
  d12.livemd#cell:i5msuh4vivy2x4cfxxjodzweyrzkfdn6:64: D12.consistent?/3

warning: variable "n" is unused (if the variable is not meant to be used, prefix it with an underscore)
  d12.livemd#cell:i5msuh4vivy2x4cfxxjodzweyrzkfdn6:64: D12.consistent?/3

warning: module attribute @is_damaged_to_char was set but never used
  d12.livemd#cell:i5msuh4vivy2x4cfxxjodzweyrzkfdn6:3

```

<!-- livebook:{"output":true} -->

```
{:module, D12, <<70, 79, 82, 49, 0, 0, 18, ...>>, {:consistent?, 3}}
```

```elixir
test_input = """
???.### 1,1,3
.??..??...?##. 1,1,3
?#?#?#?#?#?#?#? 1,3,1,6
????.#...#... 4,1,1
????.######..#####. 1,6,5
?###???????? 3,2,1
"""
```

<!-- livebook:{"output":true} -->

```
"???.### 1,1,3\n.??..??...?##. 1,1,3\n?#?#?#?#?#?#?#? 1,3,1,6\n????.#...#... 4,1,1\n????.######..#####. 1,6,5\n?###???????? 3,2,1\n"
```

```elixir
String.split("????.######..#####.", ".")
```

<!-- livebook:{"output":true} -->

```
["????", "######", "", "#####", ""]
```

```elixir
test_input = D12.parse_input(test_input)
```

<!-- livebook:{"output":true} -->

```
[
  {[nil, nil, nil, false, true, true, true], [1, 1, 3]},
  {[false, nil, nil, false, false, nil, nil, false, false, false, nil, true, true, false],
   [1, 1, 3]},
  {[nil, true, nil, true, nil, true, nil, true, nil, true, nil, true, nil, true, nil], [1, 3, 1, 6]},
  {[nil, nil, nil, nil, false, true, false, false, false, true, false, false, false], [4, 1, 1]},
  {[nil, nil, nil, nil, false, true, true, true, true, true, true, false, false, true, true, true,
    true, true, false], [1, 6, 5]},
  {[nil, true, true, true, nil, nil, nil, nil, nil, nil, nil, nil], [3, 2, 1]}
]
```

```elixir
{states, damaged} = test_input |> hd
```

<!-- livebook:{"output":true} -->

```
{[nil, nil, nil, false, true, true, true], [1, 1, 3]}
```

```elixir
D12.solve(states, damaged)
```

<!-- livebook:{"output":true} -->

```
{%{0 => nil, 1 => nil, 2 => nil},
 %{3 => false, 4 => true, 5 => true, 6 => true}, [1, 1, 3]}
```

<!-- livebook:{"output":true} -->

```
{%{0 => nil, 1 => nil, 2 => nil}, %{3 => false, 4 => true, 5 => true, 6 => true}, [1, 1, 3]}
```

```elixir

```

## Tests

```elixir
ExUnit.start(autorun: false)

defmodule D08Test do
  use ExUnit.Case, async: true

  # @test_input1 D08.parse_input("""
  #              RL

  #              AAA = (BBB, CCC)
  #              BBB = (DDD, EEE)
  #              CCC = (ZZZ, GGG)
  #              DDD = (DDD, DDD)
  #              EEE = (EEE, EEE)
  #              GGG = (GGG, GGG)
  #              ZZZ = (ZZZ, ZZZ)
  #              """)

  # @test_input2 D08.parse_input("""
  #              LLR

  #              AAA = (BBB, BBB)
  #              BBB = (AAA, ZZZ)
  #              ZZZ = (ZZZ, ZZZ)
  #              """)

  # @test_input3 D08.parse_input("""
  #              LR

  #              11A = (11B, XXX)
  #              11B = (XXX, 11Z)
  #              11Z = (11B, XXX)
  #              22A = (22B, XXX)
  #              22B = (22C, 22C)
  #              22C = (22Z, 22Z)
  #              22Z = (22B, 22B)
  #              XXX = (XXX, XXX)
  #              """)

  # @input Path.join(__DIR__, "inputs/d08") |> File.read!() |> D08.parse_input()

  # test "part 1 works" do
  #   {moves, network} = @test_input1
  #   assert D08.p1(moves, network) == 2

  #   {moves, network} = @test_input2
  #   assert D08.p1(moves, network) == 6

  #   {moves, network} = @input
  #   assert D08.p1(moves, network) == 19783
  # end

  # test "part 2 works" do
  #   {moves, network} = @test_input3
  #   assert D08.p2(moves, network) == 6

  #   {moves, network} = @input
  #   assert D08.p2(moves, network) == 9_177_460_370_549
  # end
end

ExUnit.run()
```

<!-- livebook:{"output":true} -->

```

Finished in 0.00 seconds (0.00s async, 0.00s sync)
0 failures

Randomized with seed 71107
```

<!-- livebook:{"output":true} -->

```
%{excluded: 0, failures: 0, skipped: 0, total: 0}
```
