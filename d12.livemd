<!-- livebook:{"persist_outputs":true} -->

# Day 12

## Solution

```elixir
__DIR__
```

<!-- livebook:{"output":true} -->

```
"/home/lakret/mine/aoc2023"
```

```elixir
input = Path.join(__DIR__, "inputs/d12") |> File.read!()
```

<!-- livebook:{"output":true} -->

```
".???##?????????#?.?? 1,12\n#####??.?????? 7,1\n#.???#???.#? 1,2,1,1\n?#???#?..???# 2,1,1,1\n?#..???.#?.?.. 1,2,2,1\n?#?????#?#??#?????# 2,1,8,1,1\n?#???????? 1,4,1\n#???#??#?##.???? 1,1,7,1,1\n?#?.#???#?###??? 2,3,8\n.??#????#. 3,1\n??#.??#??#?? 1,1,2,1\n?#??#?#??.?.#.#?? 8,1,1,3\n????###??#.???#..?? 7,3,1\n.##????.?? 3,2,1\n#.#???#?##??.????.? 1,2,7,1,2\n.#?.??#?????.??.?? 2,8,1\n#???..?.?. 3,1\n????#?#???..??? 1,6\n?????#???.??.???? 6,1,1,1,2\n?..?.#????#?###?#? 1,1,1,10\n.#??#?????#. 4,5\n.?????????. 1,4\n.??.?.#?#??. 1,4\n??##???.#???#??.? 5,3,2,1\n?#????#??.? 1,4,1\n#??#.??###???. 4,5,1\n?#?.#??.???# 3,2,3\n?#??.???#??? 1,1,5\n???.#????.? 2,4,1\n???#?.#??#???#?.?# 1,1,1,1,3,1\n???.#???.?#???? 1,1,3,2,1\n.#??##????. 5,2\n?????#???????.??? 3,4,1,1,3\n?...???####????#? 1,13\n.?##?#????????#???. 6,6\n???.?#???? 2,3,1\n.????????#???? 5,3,1\n..?#??..??.?? 4,1,1\n.?#???.?#? 2,1,1\n#??..???????#? 2,1,5\n??#????..??.???. 3,1,1,1\n..#??.????? 3,3\n.#?????#?..?.#?? 2,1,3,1,1\n##???..????? 4,2\n???????????#.? 1,5\n.#?#???????#???? 3,1,5,1,1\n?????#?????. 2,2,1\n?.?????###?? 2,4\n???????#???#?????? 1,1,7,1,1\n?#????##?????????? 9,1,1,1\n???????.??#????#? 6,2,1,1\n?#???..??????? 4,3,1\n.#?????#?# 4,4\n???????.???????. 2,3,2,3\n????#?#????????.??# 12,1,1,1\n.##..?.?##?#?.?.# 2,4,1,1\n#?##??#??.# 8,1\n?????.??#????? 1,1,6\n??.?..?#?.??. 1,2,2\n????#??..????? 2,1\n?.#???##???.? 1,1,2,1\n????????#?? 1,1,4\n?#???.??###????.? 4,5,1\n??.?.??#?#.???#???? 1,1,1,3,6,1\n.???#????????? 1,7\n?###????#?????.?#. 4,8,2\n?#?????????? 8,1\n?.#?#???###?.???? 1,8,1\n????#?.#???????.?? 1,8\n#????????.?#??# 2,1,1,2,1\n?.??.??#..?#.??? 1,1,2,2,2\n?????.#??.?? 1,3\n##??.?###????? 4,7\n?.?#?###??? 1,2,3\n.?????.???#? 2,4\n.??#.?##???#?? 1,5,1\n?##.??#????#???????# 3,5,1,1,1,2\n#??#???#.???###???? 1,1,2,5,1,1\n??.??.?????##?.?? 1,1,5,2\n.#??.??#???##?#.?#? 1,1,2,2,1,2\n??????####??##..?? 14,1\n????.??#?????#??... 1,1,6,1,1\n??#?.??.#.. 3,1\n.#?#????????.. 5,4\n???#?????#??#? 2,7\n????#?????#?#??#.? 8,1,1,1,1\n?#?????##.?????????? 9,1,1,1\n?#????.??#?#.??.# 1,1,5,1,1\n?????#?..? 1,3\n?.???#?#????##? 8,3\n???..?..??#?.#??##?. 2,1,4,6\n?###??.?#?#?????? 5,4,2\n?..##???????????? 4,5\n.??#.????????#..???? 1,6\n?###??????.????? 10,3\n?.#.??.?????#..??. 1,2,2,1,1,1\n??#???????#.# 8,1,1\n??.#?...?#????? 1,1,2,4\n.??????#????? 8,2\n?#?#??..??.??# 3,1,3\n.?????.????. 1,2\n?????..??????? 1,2,3,1\n..#?.??#.##??#??? 1,1,1,6\n????.?.?..? 2,1,1\n.#???.??.??? 1,1,1,1\n?.???#..??????? 1,3,6\n.?#.??..?? 1,1,1\n????????.#? 3,1\n???#?????? 1,2,2\n???#####???#?.?#.??. 12,1\n????..??.? 2,1\n.???????.???? 3,1,2,1\n??#?#???#??#??.???. 8,1,1,3\n?????###.???? 8,2\n.??..?.?#?? 2,3\n#?.????..? 1,2,1\n??????????##.#?#. 1,8,1,1\n.#????##??.?.#?? 1,1,4,1,2\n?###???.??.???.? 3,1,1,1,1\n.#?.?#???????? 2,1,2,3\n#???#?##???#?#??. 8,5\n.?#???????????.#?#? 4,2,3\n?##.??..??? 2,1\n?..???????????? 1,2,2,1,1\n.#?.??#??? 2,2\n???.???.???..#????? 2,2,1,1,3,1\n?#??????#. 3,4\n?.????#?#?????# 7,5\n??#????.?#??.. 2,2,3\n.#?????#??#??#??.?? 1,4,1,2,1,2\n???..?#???? 3,1,1\n#??#??????...?? 1,1,3,1,1\n?#??.?..#??????# 4,3,4\n??.??.??????.? 2,3,1\n..#?..?#???. 1,2\n.?????#?.? 3,1\n?#??#??#?#?#.??? 1,9\n##???.????.?#??.??? 4,1,1,3,1\n.?.?.?.????????? 1,1,4,1\n??.#????#.???##???.? 1,3,1,1,5,1\n#.??#?.?.?..? 1,2,1,1\n???.#?.???. 1,2,2\n?..#?.?#??????? 1,2,6\n#?.?##?#?? 1,3,1\n#?#.???#?#???.? 3,5,2,1\n##..?.????##?#?#???? 2,1,1,9,1\n.?#????.???? 2,4\n???..###?#??# 2,5,2\n#???.????#??? 4,2,1,1\n..?#??????..? 2,4\n??...????#.?? 1,3,1,1\n?.??##?#???.??????? 6,7\n???#?.?????#? 1,1,1,1\n??#?????????.??#?.?? 1,1,2,4,3\n?????#?#??#??????? 1,4,1,6,1\n?#???#.?#??? 2,1,1,3\n?##.??#?????.???. 2,3,3\n??#????.??? 1,5,1\n??##?????????????? 3,3,1,5\n???.?##????? 1,5,1\n?#??#.???#?????## 1,1,6,3\n.?.??#?.???#?? 2,4\n???##???.??????#???? 7,1,1,5\n??????#????.?..? 3,1,3,1,1\n?#??##???.???#.????# 7,1,1,1,1,1\n???????#.??? 1,6,2\n.#.?#?.?#? 1,1,1\n?#???#????#?.#?????? 10,1,2,1\n.?#?####??#???????. 6,9\n#?..?#.?#?#????#? 1,2,8\n.??#?##?.????#??#. 2,2,8\n????#..???????? 1,1,2,2\n??#???#..?##????? 1,2,1,8\n.????????##???. 6,4\n????#?...??.?.?#.# 5,1,1,1,1\n??.?????..#?? 1,1,1,3\n?????.???? 3,1\n.????????.??.???? 1,4,2,1,1\n?#??#???.????????? 7,2,2\n???#????.#.??##??? 4,1,4\n#??##..#?????. 1,2,2,1\n???????#??" <> ...
```

```elixir
<<a::binary-size(1), b::utf8, rest::binary>> = "abc"
{a, b, rest}
```

<!-- livebook:{"output":true} -->

```
{"a", 98, "c"}
```

```elixir
List.duplicate([1, 2, 3], 5) |> List.flatten()
```

<!-- livebook:{"output":true} -->

```
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
```

```elixir
defmodule D12 do
  def parse_input(input) do
    input
    |> String.split("\n", trim: true)
    |> Enum.map(fn line ->
      [states, damaged] = String.split(line)

      damaged =
        damaged
        |> String.split(",")
        |> Enum.map(&String.to_integer/1)

      {states, damaged}
    end)
  end

  # def solve_memo(states, damaged, memo) do
  #   known_ans = Map.get(memo, {states, damaged})
  #   if known_ans do
  #     {known_ans, memo}
  #   else
  #     ans = solve(states, damaged)
  #     {ans, Map.put(memo, {states, damaged}, ans)}
  #   end
  # end

  def solve(states, damaged, memo \\ %{}), do: solve(states, damaged, 0, memo)

  def solve("", [], _, memo), do: {1, memo}
  def solve("", [0], _, memo), do: {1, memo}
  def solve("", _, _, memo), do: {0, memo}
  def solve("#", [], _, memo), do: {0, memo}
  def solve("#", [1], _, memo), do: {1, memo}
  def solve("#", damaged, _, memo) when length(damaged) > 0, do: {0, memo}

  def solve(<<"?", rest::binary>>, [springs | damaged], continuing, memo) do
    if continuing > 0 do
      if springs > 0 do
        solve_with_memo("#" <> rest, [springs | damaged], continuing, memo)
      else
        {dot_ans, _} = solve_with_memo("." <> rest, [continuing | damaged], 0, memo)
        {hash_ans, _} = solve_with_memo("#" <> rest, damaged, continuing, memo)
        {hash_ans + dot_ans, memo}
      end
    else
      {hash_ans, memo} = solve_with_memo("#" <> rest, [springs | damaged], 0, memo)
      {dot_ans, memo} = solve_with_memo("." <> rest, [springs | damaged], 0, memo)
      {hash_ans + dot_ans, memo}
    end
  end

  def solve(<<"?", rest::binary>>, [], continuing, memo) do
    if continuing > 0 do
      solve_with_memo("." <> rest, [continuing], 0, memo)
    else
      solve_with_memo("." <> rest, [], 0, memo)
    end
  end

  def solve(<<".", rest::binary>>, damaged, continuing, memo) do
    if continuing > 0 do
      solve_with_memo(rest, [continuing | damaged], 0, memo)
    else
      solve_with_memo(rest, damaged, 0, memo)
    end
  end

  def solve(
        <<a::binary-size(1), b::binary-size(1), rest::binary>>,
        [springs | damaged],
        continuing,
        memo
      ) do
    case {a, b, springs} do
      {"#", ".", 1} ->
        solve_with_memo(b <> rest, damaged, 0, memo)

      {"#", ".", _} ->
        {0, memo}

      {"#", "#", springs} when springs < 2 ->
        {0, memo}

      {"#", "#", springs} when springs >= 2 ->
        solve(b <> rest, [springs - 1 | damaged], continuing + 1, memo)

      {"#", "?", 1} ->
        solve_with_memo("." <> rest, damaged, 0, memo)

      {"#", "?", springs} when springs > 1 ->
        solve(b <> rest, [springs - 1 | damaged], continuing + 1, memo)

      {"#", "?", _} ->
        {0, memo}

      {".", b, springs} ->
        if continuing > 0 do
          solve_with_memo(b <> rest, [continuing | springs], 0, memo)
        else
          solve_with_memo(b <> rest, springs, 0, memo)
        end
    end
  end

  def solve(<<"#", _rest::binary>>, [], _, memo), do: {0, memo}

  def solve_with_memo(states, damaged, continuing, memo) do
    case Map.get(memo, {states, damaged}) do
      nil ->
        {answer, memo} = solve(states, damaged, continuing, memo)
        memo = if continuing == 0, do: Map.put(memo, {states, damaged}, answer), else: memo
        {answer, memo}

      answer ->
        {answer, memo}
    end
  end

  def p1(input) do
    Enum.reduce(input, {[], %{}}, fn {states, damaged}, {answers, memo} ->
      {answer, memo} = solve(states, damaged, memo)
      {[answer | answers], memo}
    end)
    |> elem(0)
    |> IO.inspect(label: :x)
    |> Enum.sum()
  end

  def p2(input) do
    Enum.reduce(input, {[], %{}}, fn {states, damaged}, {answers, memo} ->
      states = List.duplicate(states, 5) |> Enum.intersperse("?") |> Enum.join()
      damaged = List.duplicate(damaged, 5) |> List.flatten()

      {answer, memo} = solve(states, damaged, memo)
      {[answer | answers], memo}
    end)
    |> elem(0)
    |> IO.inspect(label: :x)
    |> Enum.sum()
  end
end
```

<!-- livebook:{"output":true} -->

```
{:module, D12, <<70, 79, 82, 49, 0, 0, 28, ...>>, {:p2, 1}}
```

```elixir
input = input |> D12.parse_input()
```

<!-- livebook:{"output":true} -->

```
[
  {".???##?????????#?.??", [1, 12]},
  {"#####??.??????", [7, 1]},
  {"#.???#???.#?", [1, 2, 1, 1]},
  {"?#???#?..???#", [2, 1, 1, 1]},
  {"?#..???.#?.?..", [1, 2, 2, 1]},
  {"?#?????#?#??#?????#", [2, 1, 8, 1, 1]},
  {"?#????????", [1, 4, 1]},
  {"#???#??#?##.????", [1, 1, 7, 1, 1]},
  {"?#?.#???#?###???", [2, 3, 8]},
  {".??#????#.", [3, 1]},
  {"??#.??#??#??", [1, 1, 2, 1]},
  {"?#??#?#??.?.#.#??", [8, 1, 1, 3]},
  {"????###??#.???#..??", [7, 3, 1]},
  {".##????.??", [3, 2, 1]},
  {"#.#???#?##??.????.?", [1, 2, 7, 1, 2]},
  {".#?.??#?????.??.??", [2, 8, 1]},
  {"#???..?.?.", [3, 1]},
  {"????#?#???..???", [1, 6]},
  {"?????#???.??.????", [6, 1, 1, 1, 2]},
  {"?..?.#????#?###?#?", [1, 1, 1, 10]},
  {".#??#?????#.", [4, 5]},
  {".?????????.", [1, 4]},
  {".??.?.#?#??.", [1, 4]},
  {"??##???.#???#??.?", [5, 3, 2, 1]},
  {"?#????#??.?", [1, 4, 1]},
  {"#??#.??###???.", [4, 5, 1]},
  {"?#?.#??.???#", [3, 2, 3]},
  {"?#??.???#???", [1, 1, 5]},
  {"???.#????.?", [2, 4, 1]},
  {"???#?.#??#???#?.?#", [1, 1, 1, 1, 3, 1]},
  {"???.#???.?#????", [1, 1, 3, 2, 1]},
  {".#??##????.", [5, 2]},
  {"?????#???????.???", [3, 4, 1, 1, 3]},
  {"?...???####????#?", [1, 13]},
  {".?##?#????????#???.", [6, 6]},
  {"???.?#????", [2, 3, 1]},
  {".????????#????", [5, 3, 1]},
  {"..?#??..??.??", [4, 1, 1]},
  {".?#???.?#?", [2, 1, 1]},
  {"#??..???????#?", [2, 1, 5]},
  {"??#????..??.???.", [3, 1, 1, 1]},
  {"..#??.?????", [3, 3]},
  {".#?????#?..?.#??", [2, 1, 3, 1, 1]},
  {"##???..?????", [4, 2]},
  {"???????????#.?", [1, 5]},
  {".#?#???????#????", [3, 1, ...]},
  {"?????#?????.", [2, ...]},
  {"?.?????###??", [...]},
  {"???????#???#??????", ...},
  {...},
  ...
]
```

```elixir
test_input =
  """
  ???.### 1,1,3
  .??..??...?##. 1,1,3
  ?#?#?#?#?#?#?#? 1,3,1,6
  ????.#...#... 4,1,1
  ????.######..#####. 1,6,5
  ?###???????? 3,2,1
  """
  |> D12.parse_input()
```

<!-- livebook:{"output":true} -->

```
[
  {"???.###", [1, 1, 3]},
  {".??..??...?##.", [1, 1, 3]},
  {"?#?#?#?#?#?#?#?", [1, 3, 1, 6]},
  {"????.#...#...", [4, 1, 1]},
  {"????.######..#####.", [1, 6, 5]},
  {"?###????????", [3, 2, 1]}
]
```

```elixir
D12.p1(test_input)
```

<!-- livebook:{"output":true} -->

```
x: [10, 4, 1, 1, 4, 1]
```

<!-- livebook:{"output":true} -->

```
21
```

```elixir
# 7236 is the right answer!
D12.p1(input)
```

<!-- livebook:{"output":true} -->

```
x: [5, 1, 8, 2, 8, 2, 4, 56, 3, 1, 12, 7, 1, 12, 50, 1, 2, 4, 4, 8, 2, 2, 2, 10, 4,
 1, 9, 3, 4, 11, 1, 2, 4, 6, 3, 63, 7, 6, 12, 2, 2, 3, 2, 1, 1, 1, 2, 2, 1, 2,
 ...]
```

<!-- livebook:{"output":true} -->

```
7236
```

```elixir
input
|> D12.p2()
```

<!-- livebook:{"output":true} -->

```
x: [3125, 16, 32768, 512, 1125342, 32, 5184, 2887265763, 1188, 16, 460992, 16807,
 16, 25590400, 4475810880, 81, 32, 1024, 2500, 4522632, 32, 1556, 32, 3711234,
 1024, 1, 455625, 243, 2500, 1508180, 16, 32, 5184, 412518, 768, 26506766083,
 290389, 7776, 248832, 1250, 32, 9363, 32, 256, 1, 1, 512, 5622, 1, 32, ...]
```

<!-- livebook:{"output":true} -->

```
11607695322318
```

## Tests

```elixir
ExUnit.start(autorun: false)

defmodule D08Test do
  use ExUnit.Case, async: true

  # @test_input1 D08.parse_input("""
  #              RL

  #              AAA = (BBB, CCC)
  #              BBB = (DDD, EEE)
  #              CCC = (ZZZ, GGG)
  #              DDD = (DDD, DDD)
  #              EEE = (EEE, EEE)
  #              GGG = (GGG, GGG)
  #              ZZZ = (ZZZ, ZZZ)
  #              """)

  # @test_input2 D08.parse_input("""
  #              LLR

  #              AAA = (BBB, BBB)
  #              BBB = (AAA, ZZZ)
  #              ZZZ = (ZZZ, ZZZ)
  #              """)

  # @test_input3 D08.parse_input("""
  #              LR

  #              11A = (11B, XXX)
  #              11B = (XXX, 11Z)
  #              11Z = (11B, XXX)
  #              22A = (22B, XXX)
  #              22B = (22C, 22C)
  #              22C = (22Z, 22Z)
  #              22Z = (22B, 22B)
  #              XXX = (XXX, XXX)
  #              """)

  # @input Path.join(__DIR__, "inputs/d08") |> File.read!() |> D08.parse_input()

  # test "part 1 works" do
  #   {moves, network} = @test_input1
  #   assert D08.p1(moves, network) == 2

  #   {moves, network} = @test_input2
  #   assert D08.p1(moves, network) == 6

  #   {moves, network} = @input
  #   assert D08.p1(moves, network) == 19783
  # end

  # test "part 2 works" do
  #   {moves, network} = @test_input3
  #   assert D08.p2(moves, network) == 6

  #   {moves, network} = @input
  #   assert D08.p2(moves, network) == 9_177_460_370_549
  # end
end

ExUnit.run()
```

<!-- livebook:{"output":true} -->

```

Finished in 0.00 seconds (0.00s async, 0.00s sync)
0 failures

Randomized with seed 71107
```

<!-- livebook:{"output":true} -->

```
%{excluded: 0, failures: 0, skipped: 0, total: 0}
```
