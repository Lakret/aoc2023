<!-- livebook:{"persist_outputs":true} -->

# Day 20

## Solution

```elixir
test_input =
  """
  broadcaster -> a, b, c
  %a -> b
  %b -> c
  %c -> inv
  &inv -> a
  """

test_input2 =
  """
  broadcaster -> a
  %a -> inv, con
  &inv -> b
  %b -> con
  &con -> output
  """
```

<!-- livebook:{"output":true} -->

```
"broadcaster -> a\n%a -> inv, con\n&inv -> b\n%b -> con\n&con -> output\n"
```

```elixir
defmodule D20 do
  def parse_input(input) do
    {conns, kinds} =
      input
      |> String.trim()
      |> String.split("\n")
      |> Enum.map(fn line ->
        [src, dst] = String.split(line, " -> ")
        dst = String.split(dst, ", ")

        {kind, src} =
          cond do
            src == "broadcaster" -> {:broadcaster, :broadcaster}
            String.starts_with?(src, "%") -> {:flip, String.trim_leading(src, "%")}
            String.starts_with?(src, "&") -> {:conj, String.trim_leading(src, "&")}
            true -> raise "Unknown: #{src}"
          end

        {{src, dst}, {src, kind}}
      end)
      |> Enum.unzip()

    conns = Enum.into(conns, %{})
    kinds = Enum.into(kinds, %{})

    conj_modules =
      kinds
      |> Enum.map(fn
        {name, :conj} -> name
        _ -> nil
      end)
      |> Enum.reject(&is_nil/1)
      |> MapSet.new()

    conj_inputs =
      Enum.reduce(conns, %{}, fn {src, dst}, inputs ->
        dst
        |> Enum.filter(&MapSet.member?(conj_modules, &1))
        |> Enum.reduce(inputs, fn conj_module, inputs ->
          module_inputs =
            Map.get(inputs, conj_module, MapSet.new())
            |> MapSet.put(src)

          Map.put(inputs, conj_module, module_inputs)
        end)
      end)

    %{conns: conns, kinds: kinds, conj_inputs: conj_inputs}
  end

  def init_conj_memory(input) do
    input.conj_inputs
    |> Enum.map(fn {conj_module, inputs} ->
      states = Enum.map(inputs, fn input -> {input, :low} end) |> Enum.into(%{})
      {conj_module, states}
    end)
    |> Enum.into(%{})
  end

  def press_button(input) do
    conj_memory = init_conj_memory(input)
    press_button(input, 0, 0, MapSet.new(), conj_memory, [{:button, :low, :broadcaster}])
  end

  # TODO: perhaps it makes sense to remember on-off and conj_memory to detect cycles
  def press_button(_input, low, high, on_flips, conj_memory, []) do
    {low, high, on_flips, conj_memory}
  end

  def press_button(
        %{conns: conns, kinds: kinds} = input,
        low,
        high,
        on_flips,
        conj_memory,
        [{src, signal_kind, dst} | rest]
      ) do
    # IO.puts("#{inspect(src)} -(#{inspect(signal_kind)})-> #{inspect(dst)}")

    {low, high} =
      case signal_kind do
        :low -> {low + 1, high}
        :high -> {low, high + 1}
      end

    dst_kind = kinds[dst]
    # TODO: can we extract the recursive call after the match?
    case dst_kind do
      :broadcaster ->
        pulses =
          Enum.map(
            conns[:broadcaster],
            fn dst -> {:broadcaster, signal_kind, dst} end
          )

        press_button(input, low, high, on_flips, conj_memory, rest ++ pulses)

      :flip ->
        case signal_kind do
          :high ->
            press_button(input, low, high, on_flips, conj_memory, rest)

          :low ->
            if MapSet.member?(on_flips, dst) do
              on_flips = MapSet.delete(on_flips, dst)
              pulses = Enum.map(conns[dst], fn next_dst -> {dst, :low, next_dst} end)
              press_button(input, low, high, on_flips, conj_memory, rest ++ pulses)
            else
              on_flips = MapSet.put(on_flips, dst)
              pusles = Enum.map(conns[dst], fn next_dst -> {dst, :high, next_dst} end)
              press_button(input, low, high, on_flips, conj_memory, rest ++ pusles)
            end
        end

      :conj ->
        conj_memory = put_in(conj_memory, [dst, src], signal_kind)
        remembered_pulses = conj_memory[dst] |> Map.values()

        new_pulse_kind =
          if Enum.all?(remembered_pulses, fn pulse -> pulse == :high end) do
            :low
          else
            :high
          end

        pulses = Enum.map(conns[dst], fn next_dst -> {dst, new_pulse_kind, next_dst} end)
        press_button(input, low, high, on_flips, conj_memory, rest ++ pulses)

      nil ->
        press_button(input, low, high, on_flips, conj_memory, rest)
    end
  end

  # TODO: {low, high, on_flips, conj_memory} as State struct?
  def p1(input) do
    conj_memory = init_conj_memory(input)

    {low, high, _, _} =
      Enum.reduce(
        1..1000,
        {0, 0, MapSet.new(), conj_memory},
        fn _, {low, high, on_flips, conj_memory} ->
          press_button(input, low, high, on_flips, conj_memory, [{:button, :low, :broadcaster}])
        end
      )

    low * high
  end
end
```

<!-- livebook:{"output":true} -->

```
{:module, D20, <<70, 79, 82, 49, 0, 0, 35, ...>>, {:p1, 1}}
```

```elixir
test_input = D20.parse_input(test_input)
```

<!-- livebook:{"output":true} -->

```
%{
  kinds: %{:broadcaster => :broadcaster, "a" => :flip, "b" => :flip, "c" => :flip, "inv" => :conj},
  conj_inputs: %{"inv" => MapSet.new(["c"])},
  conns: %{
    :broadcaster => ["a", "b", "c"],
    "a" => ["b"],
    "b" => ["c"],
    "c" => ["inv"],
    "inv" => ["a"]
  }
}
```

```elixir
test_input2 = D20.parse_input(test_input2)
```

<!-- livebook:{"output":true} -->

```
%{
  kinds: %{:broadcaster => :broadcaster, "a" => :flip, "b" => :flip, "con" => :conj, "inv" => :conj},
  conj_inputs: %{"con" => MapSet.new(["a", "b"]), "inv" => MapSet.new(["a"])},
  conns: %{
    :broadcaster => ["a"],
    "a" => ["inv", "con"],
    "b" => ["con"],
    "con" => ["output"],
    "inv" => ["b"]
  }
}
```

```elixir
D20.p1(test_input)
```

<!-- livebook:{"output":true} -->

```
32000000
```

## Tests

```elixir
ExUnit.start(autorun: false)

defmodule D20Test do
  use ExUnit.Case, async: true

  @test_input D20.parse_input("""
              broadcaster -> a, b, c
              %a -> b
              %b -> c
              %c -> inv
              &inv -> a
              """)

  @test_input2 D20.parse_input("""
               broadcaster -> a
               %a -> inv, con
               &inv -> b
               %b -> con
               &con -> output
               """)

  @input Path.join(__DIR__, "inputs/d20") |> File.read!() |> D20.parse_input()

  test "part 1 works" do
    assert D20.p1(@test_input) == 32_000_000
    assert D20.p1(@test_input2) == 11_687_500
    assert D20.p1(@input) == 747_304_011
  end

  # test "part 2 works" do
  #   assert D12.p2(@test_input) == 525_152
  #   assert D12.p2(@input) == 11_607_695_322_318
  # end
end

ExUnit.run()
```

<!-- livebook:{"output":true} -->

```
.
Finished in 0.02 seconds (0.02s async, 0.00s sync)
1 test, 0 failures

Randomized with seed 275568
```

<!-- livebook:{"output":true} -->

```
%{total: 1, failures: 0, excluded: 0, skipped: 0}
```
